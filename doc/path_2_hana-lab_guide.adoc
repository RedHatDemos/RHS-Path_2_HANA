:scrollbar:
:data-uri:
:toc2:
:imagesdir: images

== Path to HANA - Lab Guide

:numbered:

== Overview

This Lab Environment uses Ansible Tower to deploy SAP HANA Express on Red Hat Enterprise Linux 7

The password to access all services is available link:https://mojo.redhat.com/docs/DOC-1174612-accessing-red-hat-solutions-lab-in-rhpds[here]

.Goal
* Automatically deploy SAP HANA. After this lab you will have a basic understanding of how to use and modify the predefined ansible roles for installing SAP HANA with Ansible Tower and Red Hat CloudForms.

Required versions of products used:

[cols="1,1",options="header"]
|=======
|Product |Version
|Red Hat CloudForms |4.6.4
|Red Hat Enterprise Linux |7.5
|Ansible Tower |3.3.0
|Red Hat Satellite |6.4
|=======

== Requirements to access and perform this lab

=== Base requirements

* A computer with access to Internet :-)
* SSH client (for Microsoft Windows users link:https://www.putty.org/[Putty] or link:https://mobaxterm.mobatek.net/download.html[MobaXterm] is recommended)
* Firefox 17 or higher, or Chromium / Chrome

=== Obtaining or enabling access credentials

. First time login, forgot login or password? Go to https://www.opentlc.com/account

. Your username should NOT have an *@* in it.

. Partners MUST request access to RHPDS by sending an email to open-program@redhat.com.

. Passwords to the services is referred as `<to_be_provided>`. The password to access all services is available link:https://mojo.redhat.com/docs/DOC-1174612-accessing-red-hat-solutions-lab-in-rhpds[here]. If you can't access it please contact GPTE or the link:https://mojo.redhat.com/community/marketing/vertical-marketing/horizontal-solutions/people[Horizontal Solutions Team].

== Preparation

=== Provision Your Demo Environment

. Log in to the link:https://rhpds.redhat.com/[Red Hat Product Demo System] with your provided credentials.
+
image::rhpds_login.png[RHPDS]

[start=2]
. Go to *Services -> Catalogs*.
. Under *All Services -> Red Hat Solutions*, select *Path 2 HANA (pre)"
. On the right pane, click *Order*.
+
image::rhpds_catalog.png[RHPDS]
+
[NOTE]
An account in `rhpds-access-beta` group is needed to access the demo

[start=5]
. Please, read carefully all of the information on the resulting page, check the box to confirm you understood the runtime warning message, and then click *Submit*.
+
image::rhpds_order.png[RHPDS]

[IMPORTANT]
====
* It takes about 20 ~ 25 minutes for the demo to load completely and become accessible.
** Wait for the full demo to load, even if some of its systems are marked "Up."
* Watch for an email with information about how to access your demo environment.
** Make note of the email's contents: a list of hostnames, IP addresses, and your GUID.
** Whenever you see <YOUR-GUID> in the demo instructions, replace it with the GUID provided in the email.
* You can get real-time updates and status of your demo environment at https://www.opentlc.com/rhpds-status.
====

[TIP]
Be mindful of the runtime of your demo environment! It may take several hours to complete the demo, so you may need to extend the runtime. This is especially important in later steps when you are building virtual machines. For information on how to extend runtime and lifetime, see https://www.opentlc.com/lifecycle.

=== Environment

A full new demo environment is deployed on every request. To make the environment unique a 4 character identifier is assigned to it (i.e. `1e37`), this identifier is referred in this documentation as *YOUR-GUID*.

The demo environment consists of the following systems:

[cols="1,1,1,2",options="header"]
|=======
| Hostname | Internal IP | External name | Description
|`tower.example.com` |`10.0.0.10` | tower-<YOUR-GUID>.rhpds.opentlc.com |Jump host and Ansible Tower host
|`cf.example.com` |`10.0.0.100` |  cf-<YOUR-GUID>.rhpds.opentlc.com |CloudForms server
|`hana0.example.com` |`10.0.0.20` | hana0-<YOUR-GUID>.rhpds.opentlc.com |SAP HANA host
|`hana1.example.com` |`10.0.0.21` | hana1-<YOUR-GUID>.rhpds.opentlc.com |SAP HANA host
|`satellite.example.com` |`10.0.0.101` | satellite-<YOUR-GUID>.rhpds.opentlc.com |Red Hat Satellite server
|=======

== Getting Started

. Once the system is running, use SSH to access your demo server using your OPENTLC login name and private SSH key.

* Using a Unix/Linux system:
+
----
$ ssh -i /path/to/private_key <YOUR-OpenTLC-USERNAME-redhat.com>@tower-<YOUR-GUID>.rhpds.opentlc.com
----

* Example for user 'batman' and GUID '1e37', using the default ssh private key:
+
----
$ ssh -i ~/.ssh/id_rsa batman-redhat.com@tower-1e37.rhpds.opentlc.com
----

. Become `root` using the provided password:
+
----
$ sudo -i
----

. Check the status of the environment using ansible:
+
----
# ansible all -m ping
----
+
This command establishes a connection to all the machines in the environment (except ESXi servers).
In case the machines are up an running a success message, per each, will show up.
This is an example of a success message for the VM jboss0.example.com:
+
----
cf.example.com | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
----

== Ansible foundation

This training requires the knowledge of the ansible foundation training. To fully understand this training you should have done the ansible foundation lab before you run this lab.

////

### Provision the Ansible Lab Environment

 1. Access the https://labs.opentlc.com/[OPENTLC lab portal], which is built on top of Red Hat CloudForms.
 2. Use your credentials to log in.
 3. After you log in, navigate to *Services → Catalogs → All Services → OPENTLC Cloud Infrastructure Labs*.
 4. On the left side of the screen, locate *Ansible Foundations Lab* and click *Order*, which appears on the right.
 5. On the next screen, on the lower right side, click Submit to order your Ansible Foundations environment.
 6. Check your email for a message from Red Hat describing how to connect to the environment.
 7. Wait about 20 minutes to allow the environment to build.


=== Your Lab Environment

In this lab you work in a pre-configured lab environment.
You will have access to the following hosts:

[cols="v,v,v,v"]
|===
|Role|Hostname Ext|Hostname Int|Internal IP

|Jump Host & Ansible Control Host|tower-<GUID>.rhpds.opentlc.com|tower.example.com |192.168.1.1
|Managed Host 1||servera.example.com|192.168.1.21
|Managed Host 2||serverb.example.com|192.168.1.22

|===

WARNING: You will be able to SSH into the control host, from here you need to SSH into the other hosts.

////
////
This is required for environment in rhpds
////
////
=== Install Ansible

1. Connect to the control node (tower):

   # ssh your-sso-login@tower-GUID.rhpds.opentlc.com

2. Become the `root` user:

   # sudo -i

3.  Run a script that attaches the `Extra Packages` pool to make Ansible packages available, installs ansible and creates the ansible user, which will be used in this tutorial:

    # curl https://people.redhat.com/mkoch/training/scripts/setup_ansible_env.sh | bash

4. Check that Ansible is installed and usable:

  # ansible --version
  ansible 2.2.1.0
    config file = /etc/ansible/ansible.cfg
    configured module search path = Default w/o overrides

////
////
Use this if you can prepare the environment
////
////
////
////
== Check the Prerequisites

Most prerequisite tasks have already been done for you:

* Ansible software is installed
* SSH connection and keys are configured
* `sudo` has been configured on the managed hosts to run commands that require root privileges.

Check Ansible has been installed correctly
----
[root@control ~]# ansible --version
ansible 2.5.0
  config file = /etc/ansible/ansible.cfg
[...]
----
////
=== Check the Prerequisites

NOTE: Ansible is keeping configuration management simple. Ansible requires no database or running daemons and can run easily on a laptop. On the managed hosts it needs no running agent.

Double-check that the managed hosts accept password-less connections with key authentication from the tower-GUID node as user root, e.g.:
----
[root@tower ~]# ssh hana0.example.com
[root@hana0 ~]$ exit
----
----
[root@tower ~]$ ssh serverb.example.com
[root@hana0 ~]$ exit
----
TIP: You can check the installation, disks of the server. It looks like a blank RHEL installation from DVD.

==== Working the Labs

You might have guessed by now this lab is pretty commandline-centric... :-)

* Don't type everything manually, use copy & paste from the browser when appropriate. But do stop to think and understand... ;-)
* All labs where prepared using Vi, but feel free to use mc (function keys can be reached via Esc-<n>) or nano.

TIP: In the lab guide commands you are supposed to run are shown with or without the expected output, whatever makes more sense in the context.

TIP: The command line can wrap on the web page from time to time. Therefor the output is separated from the command line for better readability by an empty line. *Anyway, the line you should actually run should be recognizable by the prompt.* :-)

==== Challenge Labs

You will soon discover that many chapters in this lab guide come with a "Challenge Lab" section. These labs are meant to give you a small task to solve using what you have learned so far. The solution of the task is shown underneath a warning sign.

////
=== Getting Started with Ansible

==== The Inventory

To use the ansible command for host management, you need to provide an inventory file which defines a list of hosts to be managed from the control node. One way to do this is to specify the path to the inventory file with the `-i` option to the ansible command.

Make sure you are user ansible on tower-GUID. Create a directory for your Ansible files:
----
[ansible@tower-GUID ~]$ mkdir ansible-files
----

Now create a simple inventory file as `~/ansible-files/inventory` with the following content:
----
servera.example.com
serverb.example.com
----

To reference inventory hosts, you supply a host pattern to the ansible command. Ansible has a `--list-hosts` option which can be useful for clarifying which managed hosts are referenced by the host pattern in an ansible command.

The most basic host pattern is the name for a single managed host listed in the inventory file. This specifies that the host will be the only one in the inventory file that will be acted upon by the ansible command. Run:

----
[ansible@tower-GUID ~]$ ansible "servera.example.com" -i ~/ansible-files/inventory --list-hosts

  hosts (1):
    servera.example.com
----

An inventory file can contain a lot more information, it can organize your hosts in groups or define variables. You will use grouping most of the times, change your inventory file to look like this:
----
[webserver]
servera.example.com

[database]
serverb.example.com

[ftpserver]
serverb.example.com
----

Now run Ansible with these host patterns and observe the output:
----
[ansible@tower-GUID ~]$ ansible webserver -i ~/ansible-files/inventory --list-hosts
[ansible@tower-GUID ~]$ ansible webserver,serverb.example.com -i ~/ansible-files/inventory --list-hosts
[ansible@tower-GUID ~]$ ansible '*.example.com' -i ~/ansible-files/inventory --list-hosts
[ansible@tower-GUID ~]$ ansible all -i ~/ansible-files/inventory --list-hosts
----

TIP: It is ok to put systems in more than one group, for instance a server could be both a web server and a database server.

TIP: The inventory can contain more data. E.g. if you have hosts that run on non-standard SSH ports you can put the port number after the hostname with a colon. Or you could define names specific to Ansible and have them point to the "real" IP or hostname.

==== The Ansible Configuration Files

The behavior of Ansible can be customized by modifying settings in Ansible's ini-style configuration file. Ansible will select its configuration file from one of several possible locations on the control node, please refer to the documentation.

TIP: The recommended practice is to create an `ansible.cfg` file in a directory from which you run Ansible commands. This directory would also contain any files used by your Ansible project, such as the inventory and Playbooks.

Make sure your inventory file is used by default when executing commands from the `~/ansible-files/` directory:

* On tower-GUID as ansible create the file `~/ansible-files/ansible.cfg` with the following content:
----
[defaults]
inventory=/home/ansible/ansible-files/inventory
----

* Check with `ansible --version`, first from ansible's home directory and then from `~/ansible-files/`. You should find when run from `~/ansible-files/` your personal config settings override the main config file.
* From `~/ansible-files/` run `ansible all --list-hosts`.

Your Ansible inventory was used without providing the `-i` option. To double-check, run the command again from outside `~/ansible-files/`:

----
[ansible@tower-GUID ~]$ ansible all --list-hosts

 [WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

  hosts (0):
----

==== Running Ansible Ad-Hoc Commands

Ansible allows administrators to execute on-demand tasks on managed hosts. These ad hoc commands are the most basic operations that can be performed with Ansible. They are great for learning about Ansible, for trying new things or for quick non-intrusive tasks like reporting. Let's try something straight forward:

WARNING: *Don't forget to run the commands from `~/ansible-files/` where your `ansible.cfg` file is located, otherwise it will complain about an empty host list.*

Run the examples on tower-GUID from the `~/ansible-files/` directory as user ansible.
----
[ansible@tower-GUID ansible-files]$ ansible all -m ping
----

The `-m` option defines which Ansible module to use. Options can be passed to the specified modul using the `-a` option. BTW the `ping` module is not running an ICMP ping but does a simple connection test.

TIP: Think of a module as a tool which is designed to accomplish a specific task.

==== Listing Modules and Getting Help

Ansible comes with a lot of modules by default. To list all modules run:

----
[ansible@tower-GUID ansible-files]$ ansible-doc -l
----

TIP: In `ansible-doc` use the `up`/`down` arrows to scroll through the content and leave with `q`.

To find a module try e.g.:
----
[ansible@tower-GUID ansible-files]$ ansible-doc -l | grep -i user
----

Get help for a specific module including usage examples:
----
[ansible@tower-GUID ansible-files]$ ansible-doc user
----

TIP: Mandatory options are marked by a "=" in `ansible-doc`.

==== More Ad Hoc Commands

Let's try a simple module that just executes a command on a managed host:
----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m command -a 'id'

servera.example.com | SUCCESS | rc=0 >>
uid=1000(ansible) gid=1000(ansible) groups=1000(ansible),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
----

In this case the module is called `command` and the option passed with `-a` is the actual command to run. Try to run this ad hoc command on both hosts using the `all` host pattern.

Another example: Have a quick look at the kernel versions your hosts are running:
----
[ansible@tower-GUID ansible-files]$ ansible all -m command -a 'uname -r'
----

Sometimes it's desirable to have the output for a host on one line:
----
[ansible@tower-GUID ansible-files]$ ansible all -m command -a 'uname -r' -o
----

Using the `copy` module, execute an ad hoc command on tower-GUID to change the contents of the `/etc/motd` file on servera.example.com. *The content is handed to the module through an option in this case*.

Run:

WARNING: Expect an error!

----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m copy -a 'content="Managed by Ansible\n" dest=/etc/motd'
----
Output:

----
servera.example.com | FAILED! => {
    "changed": false,
    "checksum": "a314620457effe3a1db7e02eacd2b3fe8a8badca",
    "failed": true,
    "msg": "Destination /etc not writable"
}

----

Should be all red for you, the ad hoc command failed. Why? Because user ansible is not allowed to write the motd file.

Now this is a case for privilege escalation and the reason `sudo` has to be setup properly. We need to instruct ansible to use `sudo` to run the command as root by using the parameter `-b` (think "become").

TIP: Ansible will connect to the machines using your current user name (ansible in this case), just like SSH would. To override the remote user name, you could use the `-u` parameter.

For us it's okay to connect as ansible because `sudo` is set up. Change the command to use the `-b` parameter and run again:
----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m copy -a 'content="Managed by Ansible\n" dest=/etc/motd' -b
----
Output:

----
servera.example.com | SUCCESS => {
    "changed": true,
    "checksum": "a314620457effe3a1db7e02eacd2b3fe8a8badca",
    "dest": "/etc/motd",
    "gid": 0,
    "group": "root",
    "md5sum": "7a924f6b4cbcbc7414eda7763dc0e43b",
    "mode": "0644",
    "owner": "root",
    "secontext": "system_u:object_r:etc_t:s0",
    "size": 19,
    "src": "/home/ansible/.ansible/tmp/ansible-tmp-1472132609.82-261447806330276/source",
    "state": "file",
    "uid": 0
}
----

Check the motd file:
----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m command -a 'cat /etc/motd'

servera.example.com | SUCCESS | rc=0 >>
Managed by Ansible
----

Run the `ansible servera.example.com -m copy ...` command from above again. Note:

* the different output color (proper terminal config provided)
* the change from `"changed": true,` to `"changed": false,`.

TIP: This makes it a lot easier to spot changes and what Ansible actually did.

==== Challenge Lab: Modules

* Using `ansible-doc`
** Find a module that uses Yum to manage software packages.
** Look up the help examples for the module to learn how to install a package in the latest version
* Run an Ansible ad hoc command to install the package "screen" in the latest version on servera.example.com

TIP: Use the copy ad hoc command from above as a template and change the module and options.

WARNING: *Solution below!*

----
[ansible@tower-GUID ansible-files]$ ansible-doc -l | grep -i yum
[ansible@tower-GUID ansible-files]$ ansible-doc yum
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m yum -a 'name=screen state=latest' -b
----


=== Ansible Playbooks: Introduction

While Ansible ad hoc commands are useful for simple operations, they are not suited for complex configuration management or orchestration scenarios.

Playbooks are files which describe the desired configurations or steps to implement on managed hosts. Playbooks can change lengthy, complex administrative tasks into easily repeatable routines with predictable and successful outcomes.

TIP: Here is a nice analogy: When Ansible modules are the tools in your workshop, the inventory is the materials and the Playbooks are the instructions.

==== Playbook Basics

Playbooks are text files written in YAML format and therefore need:

* to start with three dashes (`---`)
* proper identation using spaces and *not* tabs!

There are some important concepts:

* *hosts*: the managed hosts to perform the tasks on
* *tasks*: the operations to be performed by invoking Ansible modules and passing them the necessary options.
* *become*: privilege escalation in Playbooks, same as using `-b` in the ad hoc command.

WARNING: The ordering of the contents within a Playbook is important, because Ansible executes plays and tasks in the order they are presented.

A Playbook should be *idempotent*, so if a Playbook is run once to put the hosts in the correct state, it should be safe to run it a second time and it should make no further changes to the hosts.

TIP: Most Ansible modules are idempotent, so it is relatively easy to ensure this is true.

TIP: Try to avoid the command, shell, and raw modules in Playbooks. Because these take arbitrary commands, it is very easy to end up with non-idempotent Playbooks with these modules.

=== Your first Playbook

Enough theory, it's time to create your first Playbook. In this lab you create a Playbook to set up an Apache webserver in three steps:

* First step: Install httpd package
* Second step: Enable/start httpd service
* Third step: Create an index.html file

==== Playbook: Install Apache

This Playbook makes sure the package containing the Apache webserver is installed on servera.example.com.

TIP: You obviously need to use privilege escalation to install a package or run any other task that requires root permissions. This is done in the Playbook by `become: yes`.

On tower-GUID as user ansible create the file `~/ansible-files/apache.yml` with the following content:
----
---
- name: Apache server installed
  hosts: servera.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
----

This shows one of Ansible's strenghts: The Playbook syntax is easy to read and understand. In this Playbook:

* A name is given for the play
* The host to run against and privilege escalation is configured
* A task is defined and named, here it uses the module "yum" with the needed options.

==== Running Playbooks

Playbooks are executed using the `ansible-playbook` command on the control node. Before you run a new Playbook it's a good idea to check for syntax errors:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook --syntax-check apache.yml
----

Now you should be ready to run your Playbook:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook apache.yml
----

Use SSH to make sure Apache has been installed on servera.example.com.

----
[ansible@tower-GUID ansible-files]$ ssh servera.example.com rpm -qi httpd

Name        : httpd
Version     : 2.4.6
[...]
----

Or even better use an Ansible ad hoc command!

----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m command -a 'rpm -qi httpd'
----

Run the Playbook a second time.

TIP: The different colors, the "ok" and "changed" counters and the "PLAY RECAP" make it easy to spot what Ansible actually did.

==== Extend your Playbook: Start & Enable Apache

The next part of the Playbook makes sure the Apache webserver is enabled and started on servera.example.com.

On tower-GUID as user ansible edit the file `~/ansible-files/apache.yml` to add a second task using the `service` module. The Playbook should now look like this:
----
---
- name: Apache server installed
  hosts: servera.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
----

And again what it does is easy to understand:

* a second task is defined
* a module is specified (`service`)
* options are supplied

WARNING: As this is YAML take care of the correct indentation when copy/pasting!

Run your extended Playbook:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook apache.yml
----

* Note some tasks are shown as "ok" in green and one is shown as "changed" in yellow.
* Use an Ansible ad hoc command again to make sure Apache has been enabled and started, e.g. with:
`systemctl status httpd`
* Run the Playbook a second time to get used to the change in the output.

==== Extend your Playbook: Create an index.html

Check that the tasks where executed correctly and Apache is accepting connections: Make an HTTP request using Ansible's `uri` module in an ad hoc command from the control node:
----
[ansible@tower-GUID ansible-files]$ ansible localhost -m uri -a "url=http://servera.example.com/"
----

WARNING: Expect a lot of red lines and a 403 status!

As long as there is not at least an `index.html` file to be served by Apache, it will throw an ugly "HTTP Error 403: Forbidden" status and Ansible will report an error.

So why not use Ansible to deploy a simple `index.html` file? Create the file `~/ansible-files/index.html` on the control node:
----
<body>
<h1>Apache is running fine</h1>
</body>
----

You already used Ansible's `copy` module to write text supplied on the commandline into a file. Now you'll use the module in your Playbook to actually copy a file:

On tower-GUID as user ansible edit the file `~/ansible-files/apache.yml` and add a new task utilizing the `copy` module. It should now look like this:
----
---
- name: Apache server installed
  hosts: servera.example.com
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
  - name: copy index.html
    copy:
      src: ~/ansible-files/index.html
      dest: /var/www/html/
----

You are getting used to the Playbook syntax, so what happens? The new task uses the `copy` module and defines the source and destination options for the copy operation.

Run your extended Playbook:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook apache.yml
----

* Have a good look at the output
* Run the ad hoc command using the "uri" module to test Apache again.

The command should now return a friendly green "status: 200" line, amongst other information.

==== Challenge Lab: Playbooks

This was nice but the real power of Ansible is to apply the same set of tasks reliably to many hosts.

* Change the apache.yml Playbook to run on servera *and* serverb.example.com.

TIP: There are multiple ways to do this, try to edit the "webserver" group in your inventory file to include both hosts and change your Playbook to use the group in `hosts:`

* Run the Playbook
* Test using the ad hoc command with the `uri` module.

WARNING: *Solution below!*

The changed inventory file:
----
[webserver]
servera.example.com
serverb.example.com

[database]
serverb.example.com

[ftpserver]
serverb.example.com
----

The Playbook now pointing to the group "webserver":
----
---
- name: Apache server installed
  hosts: webserver
  become: yes
  tasks:
  - name: latest Apache version installed
    yum:
      name: httpd
      state: latest
  - name: Apache enabled and running
    service:
      name: httpd
      enabled: true
      state: started
  - name: copy index.html
    copy:
      src: ~/ansible-files/index.html
      dest: /var/www/html/
----

Run the Playbook:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook apache.yml
----

And the commands to check if Apache is now running on both servers:
----
[ansible@tower-GUID ansible-files]$ ansible localhost -m uri -a "url=http://servera.example.com/"
----
----
[ansible@tower-GUID ansible-files]$ ansible localhost -m uri -a "url=http://serverb.example.com/"
----

=== Ansible Variables

==== Introduction

Ansible supports variables to store values that can be used in Playbooks. Variables can be defined in a variety of places and have a clear precedence. Ansible substitutes the variable with its value when a task is executed.

*Variables are referenced in Playbooks by placing the variable name in double curly braces.*
----
Here comes a variable {{ variable1 }}
----

The recommended practice is to define variables in files located in two directories named `host_vars` and `group_vars`:

* To e.g. define variables for a group "servers", create a YAML file named `group_vars/servers` with the variable definitions.

* To define variables specifically for a host "servera.example.com", create the file `host_vars/servera.example.com` with the variable definitions.

TIP: Host variables take precedence over group variables (more about precedence can be found in the docs).

==== Off to the Lab

For understanding and practice let's do a lab. Following up on the theme "Let's build a webserver. Or two. Or even more..." you will change the `index.html` to show the development environment (dev/prod) a server is deployed in.

On tower-GUID as user ansible create the directories to hold the variable definitions in `~/ansible-files/`:

----
[ansible@tower-GUID ansible-files]$ mkdir host_vars group_vars
----

==== Create the Variable Files

Now create two files containing variable definitions. We'll define a variable named `stage` which will point to different environments, `dev` or `prod`:

* `~/ansible-files/group_vars/webserver` with this content:
----
---
stage: dev
----

* `~/ansible-files/host_vars/serverb.example.com`, content:
----
---
stage: prod
----

What is this about?

* For all servers in the `webserver` group the variable `stage` with value `dev` is defined. So as default we flag them as members of the dev environment.
* For server "serverb.example.com" this is overriden and the host is flagged as a production server.

==== Create index.html Files

Now create two files in `~/ansible-files/`:

One called `prod_index.html` with the following content:
----
<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

And the other called `dev_index.html` with the following content:
----
<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----

==== Create the Playbook

Now you need a Playbook that copies the prod or dev index.html file according to the "stage" variable.

Create a new Playbook called `deploy_index_html.yml` in the `~/ansible-files/` directory.

TIP: Note how the variable "stage" is used in the name of the file to copy.

----
---
- name: Copy index.html
  hosts: webserver
  become: yes
  tasks:
  - name: copy index.html
    copy:
      src: ~/ansible-files/{{ stage }}_index.html
      dest: /var/www/html/index.html
----

* Run the Playbook:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook deploy_index_html.yml
----

==== Test the Result

The Playbook should copy different files as index.html to the hosts, use `curl` to test it:
----
[ansible@tower-GUID ansible-files]$ curl http://servera.example.com

<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----
----
[ansible@tower-GUID ansible-files]$ curl http://serverb.example.com

<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

TIP: If by now you think: There has to be a smarter way to change content in files... you are absolutely right. This lab was done to introduce variables, you are about to learn about templates in one of the next labs.

=== Ansible Facts

Ansible facts are variables that are automatically discovered by Ansible from a managed host. Facts are pulled by the `setup` module and contain useful information stored into variables that administrators can reuse.

To get an idea what facts Ansible collects by default, on tower-GUID as user ansible from the `~/ansible-files/` directory run:

----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m setup
----

TIP: You still remember why you have to run ansible from this directory?

This might be a bit too much, you can use filters to limit the output to certain facts, the expression is shell-style wildcard:
----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m setup -a 'filter=ansible_eth0'
----

Or what about only looking for memory related facts:
----
[ansible@tower-GUID ansible-files]$ ansible all -m setup -a 'filter=ansible_*_mb'
----

==== Challenge Lab: Facts

* Try to find and print the distribution (Red Hat) of your managed hosts. On one line, please.

TIP: Use grep to find the fact, then apply a filter to only print this fact.

WARNING: *Solution below!*

----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m setup | grep distribution
----
----
[ansible@tower-GUID ansible-files]$ ansible all -m setup -a 'filter=ansible_distribution' -o
----

==== Using Facts in Playbooks

Facts can be used in a Playbook like variables, using the proper naming, of course. Create this Playbook as `facts.yml` in the `~/ansible-files/` directory:
----
---
- name: Output facts within a playbook
  hosts: all
  tasks:
  - name: Prints Ansible facts
    debug:
      msg: The default IPv4 address of {{ ansible_fqdn }} is {{ ansible_default_ipv4.address }}
----

TIP: The "debug" module is handy for e.g. debugging variables or expressions.

Execute it to see how the facts are printed:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook facts.yml

PLAY [all] *********************************************************************

TASK [setup] *******************************************************************
ok: [servera.example.com]
ok: [serverb.example.com]

TASK [Prints various Ansible facts] ********************************************
ok: [servera.example.com] => {
    "msg": "The default IPv4 address of servera.example.com is 192.168.1.21\n"
}
ok: [serverb.example.com] => {
    "msg": "The default IPv4 address of serverb.example.com is 192.168.1.22\n"
}

PLAY RECAP *********************************************************************
servera.example.com          : ok=2    changed=0    unreachable=0    failed=0
serverb.example.com          : ok=2    changed=0    unreachable=0    failed=0
----

=== Ansible Conditionals

Ansible can use conditionals to execute tasks or plays when certain conditions are met.

To implement a conditional, the `when` statement must be used, followed by the condition to test. The condition is expressed using one of the available operators like e.g. for comparison:

|===
|==|Compares two objects for equality.
|!=| Compares two objects for inequality.
|>|true if the left hand side is greater than the right hand side.
|>=|true if the left hand side is greater or equal to the right hand side.
|<|true if the left hand side is lower than the right hand side.
|< =|true if the left hand side is lower or equal to the right hand side.
|===

For more on this, please refer to the documentation: http://jinja.pocoo.org/docs/2.9/templates/

==== Inventory Group Membership in Conditional

As an example you would like to install an FTP server, but only on hosts that are in the "ftpserver" inventory group.

As user ansible create this Playbook on tower-GUID as `ftpserver.yml` in the `~/ansible-files/` directory, run it and examine the output:
----
---
- name: Install vsftpd on ftpservers
  hosts: all
  become: yes
  tasks:
    - name: Install FTP server when host in ftpserver group
      yum:
        name: vsftpd
        state: latest
      when: inventory_hostname in groups["ftpserver"]
----

TIP: The when statement must be placed "outside" of the module by being indented at the top level of the task.

Expected outcome: The task is skipped on servera.example.com because it is not in the ftpserver group in your inventory file:
----
[...]
TASK [Install FTP server when host in ftpserver group] *************************
skipping: [servera.example.com]
changed: [serverb.example.com]
[...]
----

==== Challenge Lab: Fact in Conditional

Admittedly using an inventory group as a condition is the most basic case you would expect to just work. Let's try something a bit more interesting:

You might have noticed servera and serverb have different amounts of RAM. If not have another look at the facts:
----
[ansible@tower-GUID ansible-files]$ ansible all -m setup -a 'filter=ansible_*_mb'
----

Write a Playbook `mariadb.yml` that installs MariaDB but only if the host has more then, say, 3000 MB of RAM.

* Find the fact for memtotal in MB (look at the ad hoc command output and feel free to use "grep").
* Use this Playbook as a template and create the when statement by *replacing the upper case placeholders*:

WARNING: In a `when` statement facts and variables are *not* to be inclosed in double curly braces like you would do for variables!

----
---
- name: MariaDB server installation
  hosts: all
  become: yes
  tasks:
  - name: Install latest MariaDB server when host RAM greater 3000 MB
    yum:
      name: mariadb-server
      state: latest
    when: FACT COMPARISON_OPERATOR NUMBER
----

* Run the Playbook. As a result the installation task should be skipped on serverb.

WARNING: *Solution below!*

----
---
- name: MariaDB server installation
  hosts: all
  become: yes
  tasks:
  - name: Install latest MariaDB server when host RAM greater 3000 MB
    yum:
      name: mariadb-server
      state: latest
    when: ansible_memtotal_mb > 3000
----


=== Ansible Handlers

Sometimes when a task does make a change to the system, a further task may need to be run. For example, a change to a service's configuration file may then require that the service be reloaded so that the changed configuration takes effect.

Here Ansible's handlers come into play. Handlers can be seen as inactive tasks that only get triggered when explicitly invoked using the "notify" statement.

As a an example, let's write a Playbook that:

* manages Apache's configuration file `httpd.conf` on all hosts in the `webserver` group
* restarts Apache when the file has changed

First we need the file Ansible will deploy, let's just take the one from tower-GUID:
----
[ansible@tower-GUID ansible-files]$ scp servera.example.com:/etc/httpd/conf/httpd.conf .
----

Then create the Playbook `httpd_conf.yml`:

----
---
- name: manage httpd.conf
  hosts: webserver
  become: yes
  tasks:
  - name: Copy Apache configuration file
    copy:
      src: httpd.conf
      dest: /etc/httpd/conf/
    notify:
       - restart_apache
  handlers:
    - name: restart_apache
      service:
        name: httpd
        state: restarted
----

So what's new here?

* The "notify" section calls the handler only when the copy task changed the file.
* The "handlers" section defines a task that is only run on notification.

Run the Playbook. We didn't change anything in the file yet so there should not be any `changed` lines in the output and of course the handler shouldn't have fired.

* Now change the `Listen 80` line in httpd.conf to:
----
Listen 8080
----

* Run the Playbook again. Now the Ansible's output should be a lot more interesting:
** httpd.conf should have been copied over
** The handler should have restarted Apache

Apache should now listen on port 8080. Easy enough to verify:
----
[ansible@tower-GUID ansible-files]$ curl http://serverb.example.com

curl: (7) Failed connect to serverb.example.com:80; Connection refused
----
----
[ansible@tower-GUID ansible-files]$ curl http://serverb.example.com:8080

<body>
<h1>This is a production webserver, take care!</h1>
</body>
----

Feel free to change the httpd.conf file again and run the Playbook.


=== Ansible Templates

Ansible uses Jinja2 templating to modify files before they are distributed to managed hosts. Jinja2 is one of the most used template engines for Python (http://jinja.pocoo.org/).

==== Using Templates in Playbooks

When a template for a file has been created, it can be deployed to the managed hosts using the `template` module, which supports the transfer of a local file from the control node to the managed hosts.

As an example of using templates you will change the motd file to contain host-specific data.

In the `~/ansible-files/` directory on tower-GUID as user ansible create the template file `motd-facts.j2`:

----
Welcome to {{ ansible_hostname }}.
{{ ansible_distribution }} {{ ansible_distribution_version}}
deployed on {{ ansible_architecture }} architecture.
----

In the `~/ansible-files/` directory on tower-GUID as user ansible create the Playbook `motd-facts.yml`:

----
---
- name: Fill motd file with host data
  hosts: servera.example.com
  become: yes
  tasks:
    - template:
        src: motd-facts.j2
        dest: /etc/motd
        owner: root
        group: root
        mode: 0644
----

You have done this a couple of times by now:

* Understand what the Playbook does.
* Execute the Playbook `motd-facts.yml`
* Login to servera.example.com via SSH and check the motto of the day message.
* Log out of servera.example.com

You should see how Ansible replaces the variables with the facts it discovered from the system.

==== Challenge Lab

Change the template to use the FQDN hostname:

* Find a fact that contains the fully qualified hostname using the commands you learned in the "Ansible Facts" chapter.

TIP: Do a `grep -i` for fqdn

* Change the template to use the fact you found.
* Run the Playbook again.
* Check motd by logging in to servera.example.com

WARNING: *Solution below!*

* Find the fact:
----
[ansible@tower-GUID ansible-files]$ ansible servera.example.com -m setup | grep -i fqdn
----

* Use the `ansible_fqdn` fact in the template `motd-facts.j2`.

So you finished the first part of the training.
But it doesn't have to end here. We prepared some slightly more advanced bonus labs for you to follow through if you like.

=== Bonus Labs

If you are done with the labs and still have some time, here are some more labs for you:

==== Bonus Lab: Ad Hoc Commands

* Create a new user "testuser" on servera and serverb using an ad hoc command
** Find the parameters for the appropriate module using `ansible-doc user` (leave with `q`)
** Use an Ansible ad hoc command to create the user with the comment "Test D User"
** Use the "command" module with the proper invocation to find the userid

* Delete the user and check it has been deleted

TIP: Remember privilege escalation...

WARNING: *Solution below!*

Your commands could look like these:
----
[ansible@tower-GUID ansible-files]$ ansible-doc -l | grep -i user
[ansible@tower-GUID ansible-files]$ ansible-doc user
[ansible@tower-GUID ansible-files]$ ansible all -m user -a "name=testuser comment='Test D User'" -b
[ansible@tower-GUID ansible-files]$ ansible all -m command -a " id testuser" -b
[ansible@tower-GUID ansible-files]$ ansible all -m user -a "name=testuser state=absent remove=yes" -b
[ansible@tower-GUID ansible-files]$ ansible all -m command -a " id testuser" -b
----

==== Bonus Lab: Templates and Variables

You have learned the basics about Ansible templates, variables and handlers. Let's combine all of these.

Instead of editing and copying `httpd.conf` why don't you just define a variable for the listen port and use it in a template? Here is your job:

* Define a variable "listen_port" for the `webserver` group with the value "8080" and another for `serverb.example.com` with the value "80" using the proper files.
** Remember the `group_vars` and `host_vars` directories? If not, refer to the chapter "Ansible Variables".
* Copy the `httpd.conf` file into the template `httpd.conf.j2` that uses the `listen_port` variable instead of the hard-coded port number.
* Write a Playbook that deploys the template and restarts Apache on changes using a handler.
* Run the Playbook and test the result using "curl".

WARNING: *Solution below!*

===== Define the variables:

* Add this line to `group_vars/webserver`:
----
listen_port: 8080
----

* Add this line to `host_vars/serverb.example.com`:
----
listen_port: 80
----

===== Prepare the template:

* Copy `httpd.conf` to `httpd.conf.j2`
* Edit the "Listen" directive in `httpd.conf.j2` to make it look like this:
----
[...]
Listen {{ listen_port }}
[...]
----

===== Create the Playbook `apache_config_tpl.yml`:

----
---
- name: Apache httpd.conf
  hosts: webserver
  become: yes
  tasks:
  - name: Create Apache configuration file from template
    template:
      src: httpd.conf.j2
      dest: /etc/httpd/conf/httpd.conf
    notify:
       - restart apache
  handlers:
    - name: restart apache
      service:
        name: httpd
        state: restarted
----

===== Run and test:
----
[ansible@tower-GUID ansible-files]$ ansible-playbook apache_config_tpl.yml
----
----
[ansible@tower-GUID ansible-files]$ curl http://serverb.example.com:80
<body>
<h1>This is a production webserver, take care!</h1>
</body>
----
----
[ansible@tower-GUID ansible-files]$ curl http://servera.example.com:8080
<body>
<h1>This is a development webserver, have fun!</h1>
</body>
----

==== Change a Configuration File

This lab is about how to automate a pretty common sys admin task: Make sure a configuration file setting is configured in a certain way. As an example let's make sure the SSH daemon is not accepting direct root logins.

You'll need to learn about a new module; `lineinfile`. Here is your job:

* Read the `lineinfile` doc
* Copy `apache_config_tpl.yml` to `no_sshd_root.yml` and adapt it to:
** Use the module `lineinfile` with these parameters:
*** Use the `dest` option to specify the config file (`/etc/ssh/sshd_config`)
*** Use the `line` option to provide the proper config file value (use `"PermitRootLogin no"`)
* Configure a handler `restart_sshd` to restart `sshd` when the configuration was changed.
* Test the SSH login as root, the password is the same as for everything else.

WARNING: *Solution below!*

* Create the Playbook `no_sshd_root.yml`

----
---
- name: no root login to sshd
  hosts: all
  become: yes
  tasks:
  - name: change sshd config file
    lineinfile:
      dest: /etc/ssh/sshd_config
      line: "PermitRootLogin no"
    notify:
       - restart_ssh
  handlers:
    - name: restart_ssh
      service:
        name: sshd
        state: restarted
----

* Run it and check the SSH login as root:

----
[ansible@tower-GUID ansible-files]$ ansible-playbook no_sshd_root.yml
----

----
[ansible@tower-GUID ansible-files]$ ssh root@servera.example.com
root@servera.example.com's password:
Permission denied, please try again.
----

////
== SAP HANA on RHEL 7 with Ansible

////

### Provision the HANA Lab environment

1. Access the https://labs.opentlc.com/[OPENTLC lab portal], which is built on top of Red Hat CloudForms.
 2. Use your credentials to log in.
 3. After you log in, navigate to *Services → Catalogs → All Services → OPENTLC Datacenter Infrastructure Labs*.
 4. On the left side of the screen, locate *RHEL for SAP HANA 7 Lab* and click *Order*, which appears on the right.
 5. On the next screen, on the lower right side, click Submit to order your Ansible Foundations environment.
 6. Check your email for a message from Red Hat describing how to connect to the environment.
 7. Wait about 20 minutes to allow the environment to build.


=== Your Lab Environment

In this lab you work in a pre-configured lab environment.
You will have access to the following hosts:

[cols="v,v,v,v"]
|===
|Role|Hostname Ext|Hostname Int|Internal IP

|Jump Host & Ansible Control Host|tower-<GUID>.rhpds.opentlc.com|tower.example.com |192.168.0.10
|Hana Server||hana1.example.com|192.168.0.100

|===

WARNING: You will be able to SSH into the control host, from here you can SSH into the other hosts and run the ansible playbooks.

////

We will use HANA Express for the labs as RedHat is not allowed to provide SAP software for training purpose. So you have to register and download your own HANA Express version.

### Register for download Hana Express

HANA Express is a reduced Version of SAP HANA and requires less resources than HANA Platform Edition. It lacks at least the following features:

- Smart Data Integration (SDI)
- Smart Data Streaming
- Sytem Replication (HSR)
- Dynamic tiering

For a full list see http://news.sap.com/germany/files/2017/01/SAP-HANA-Express-Edition-FAQ-extern.pdf[the HANA Express FAQ]

For this quickstart guide you need to download the Binary installer method as described in detail on this page: https://www.sap.com/developer/tutorials/hxe-ua-installing-binary.html

As the SAP tutorial only describes the graphical interface which is not feasible for the training server in the cloud, you need to do the following

* Register for Hana Express at https://www.sap.com/sap-hana-express

image::hana01.png[]

* Download the platform independant installer (HXEDownloadManager.jar)

image::hana02.png[]

* Copy the Installer to tower-GUID, e.g. from Linux or Mac:

   $ scp HXEDownloadManager.jar your-sso-login@tower-GUID.rhpds.opentlc.com:/tmp/HXEDownloadManager.jar

* Login to tower and download HANA expressed to /export

  $ ssh your-sso-login@tower-GUID
  $ sudo -i
  [root@tower ~]# cd /tmp
  [root@tower tmp]# java -jar HXEDownloadManager.jar -d /export linuxx86_64 installer hxe.tgz
  Connecting to download server...

  SAP HANA, express edition version: 2.00.030.00.20180403.2

* Now that you have downloaded HANA Express, unpack hxe.tgz in /export

  [root@tower tmp]# cd /export
  [root@tower export]# tar xzvf hxe.tgz

* Your directory should now look like this

  [root@tower export]# ls -1F
  HANA_EXPRESS_20/
  setup_hxe.sh*


=== Check the Prerequisites

NOTE: Ansible is keeping configuration management simple. Ansible requires no database or running daemons and can run easily on a laptop. On the managed hosts it needs no running agent.

For the manual installation we use the User ansible, because you would not run this stuff in a production environment as user ansible.

Verify that the managed hosts accept password-less connections with key authentication from the tower-GUID node as user ansible, e.g.:
----
[root@-GUID ~]# su - ansible
[ansible@tower-GUID ~]$ ssh hana1.example.com
[ansible@hana1 ~]$ exit
----

To allow user ansible to execute commands on hana1.example.com as root `sudo` needs to be configured on the managed hosts.

Test that the configuration allows ansible to run commands using `sudo` on hana1.example.com without a password, e.g.:
----
[ansible@tower-GUID ~]$ ssh hana1.example.com
[ansible@hana1 ~]$ sudo cat /etc/shadow
[ansible@hana1 ~]$ exit
----

NOTE: *In all subsequent exercises you should work as the ansible user on the control node if not explicitly told differently.*


=== Setup the ansible environment

In the ansible foundation training you have learned how to create basic playbooks, setup an inventory file and start.

Test your setup with an ad-hoc command

WARNING: *Solution below*

1. Create a subdirectory `ansible-files`

   $ mkdir ~/ansible-files

2. Create an inventory file with your hana host in this directory

   $ echo "hana1.example.com" > ~ansible/ansible-files/inventory

3. Make sure your inventory file is used by default when executing commands from the `~/ansible-files/` directory. On tower-GUID as ansible create the file `~/ansible-files/ansible.cfg` with the following content:

    [defaults]
    inventory=/home/ansible/ansible-files/inventory

4. Create directories for host and group variables needed later

   $ cd ~/ansible-files/
   $ mkdir host_vars group_vars

5. Test with an ad-hoc command that the ansible connection is working:
----
[ansible@tower-GUID ~]$ ansible -m ping hana1.example.com
hana1.example.com | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
----

=== Install SAP HANA with ansible roles
==== Find available roles for SAP deployment
On http://galaxy.ansible.com[Ansible Galaxy] a lot of ready to use roles exist. Red Hat maintaines the linux-system-roles, which are upstream to supported RHEL System Roles.

See the follwoing pages for more details:

   * https://access.redhat.com/articles/3050101[Red Hat Enterprise Linux (RHEL) System Roles]
   * https://galaxy.ansible.com/linux-system-roles/[Linux System Roles]

Now find the roles that are useful for installing SAP HANA on http://galaxy.ansible.com

Search for "SAP" and you will find the following roles:

 * https://galaxy.ansible.com/mk-ansible-roles/saphana-preconfigure/[saphana-preconfigure]
 * https://galaxy.ansible.com/mk-ansible-roles/saphana-deploy/[saphana-deploy]
 * https://galaxy.ansible.com/mk-ansible-roles/saphana-hsr/[saphana-hsr]

These and some other userful  useful roles can be found here: https://galaxy.ansible.com/mk-ansible-roles/[Roles Overview]

==== Install SAP HANA using these Roles

The above roles are globally installed at /etc/ansible roles already. Get familiar with these roles. e.g. read the documentation of each of the above role and browse the roles itself

-----

[ansible@tower-GUID ~]$ ansible-galaxy list
- mk-ansible-roles.saphana-preconfigure, master
- mk-ansible-roles.saphana-deploy, master
- linux-system-roles.timesync, 0.1
- mk-ansible-roles.subscribe-rhn, master

-----

NOTE: Global roles can be installed (as root) to `/usr/share/ansible/roles` using the -p option, per default roles are installed to `${HOME}/.ansible/roles`. You need to set your roles_path in `ansible.cfg` appropriately

Now go ahead and read the Readme of saphana-preconfigure role either on the web (easier to read) or on the commandline:

-----
[ansible@tower-GUID ~]$ ansible-galaxy info mk-ansible-roles.saphana-preconfigure
[ansible@tower-GUID ~]$ ansible-galaxy info mk-ansible-roles.saphana-deploy
[ansible@tower-GUID ~]$ ansible-galaxy info mk-ansible-roles.subscribe-rhn
-----


===== Information you should use in your playbooks_loops

Now write playbook to prepare `hana1.example.com` for HANA installation. The following preconditions are:

* The  lab environment has a version of Red Hat Enterprise Linux 7.4 base server already installed, but the channels for HANA installation are not correct. Use the `mk-ansible-roles.subscribe-rhn` to set the correct repositories. For this use the following variables:

  # Use the Satellie server with activation key:
  satellite_server: satellite.example.com
  reg_activation_key: sap-hana
  reg_organization_id: RHPDS_Demo
  reg_server_insecure: yes

  # Pins the release to 7.4
  reg_osrelease: 7.4

  # remove all previously set repositories
  repo_reset: true

  # subscribe to the following repositories for 4 years update services
  repositories:
              - rhel-sap-hana-for-rhel-7-server-e4s-rpms
              - rhel-7-server-e4s-rpms

NOTE: you will find more details on the Update Services for SAP in our https://access.redhat.com/solutions/3075991[Knowledbase]

* In the course we can ignore network setup  setup. These could be done with `linux-system-roles.network`. See https://access.redhat.com/articles/3050101[RHEL System Roles] for more info.

* Use the `linux-system-roles.timeserver` to configure NTP usinf the following timeserver variables:

  ntp_servers:
    - hostname: 0.rhel.pool.ntp.org
      iburst: yes
    - hostname: 1.rhel.pool.ntp.org
      iburst: yes
    - hostname: 2.rhel.pool.ntp.org
      iburst: yes
    - hostname: 3.rhel.pool.ntp.org
      iburst: yes

* To do all preconfiguration steps for SAP HANA which are described in the SAP Note 2292690 use `mk-ansible-roles.saphana-preconfigure`

** SAP Installation media is provided on an NFS share on the tower server and should be mounted to /install on the hanaservers.

    install_nfs: "tower.example.com:/export"
    installroot: /install/hxe
    installversion: "HANA_EXPRESS_20"
    hana_installdir: "{{ installroot + '/' + installversion }}"

** For the preparation of SAP users and hostagent use the following variables.

      hana_pw_hostagent_ssl: "Ab01%%bA"
      id_user_sapadm: "30200"
      id_group_shm: "30220"
      id_group_sapsys: "30200"
      pw_user_sapadm_clear: "Adm12356"

TIP: This information can also go to an appropriate group_vars file, because it can be shared across the whole SAP HANA servers

* To install SAP HANA database, use the role `mk-ansible-roles.saphana-deploy`. For this role you need to add the instance specific parameters in the according host_vars file:
    ** The first parameter to set is the hostname/interfacename of the interface SAP hostagent will use to talk. If you just have one interface use  `"{{ ansible_hostname }}"` as a default value

    hostname: "{{ ansible_hostname }}"

    ** The second parameter to set, is whether you want to prepare the installation or execute the installation.

    deployment_instance: true

     ** Now describe your instance. These variables are similar to the unattended install file:

  instances:
    hxe:
      hdblcm_params: "--ignore=check_min_mem,check_platform"
      id_user_sidadm: "30210"
      pw_user_sidadm: "Adm12356"
      hana_pw_system_user_clear: "System123"
      hana_components: "client,server"
      hana_system_type: "Master"
      id_group_shm: "30220"
      hana_instance_hostname: "{{ ansible_hostname }}"
      hana_addhosts:
      hana_sid: HXE
      hana_instance_number: 90
      hana_system_usage: custom

NOTE: The backend you are using in this course is a test environment that is not officially supported by SAP, as such depending on the HANA installer version
the installation prerequisite checks fail. To be safe add the following line to your instance: `hdblcm_params: "--ignore=check_platform"`,  add the parameter `check_min_mem` if your installation is below 32GB. With this HANA express can be installed on 16GB servers.

NOTE:   In case of deploying a HANA scale-out cluster only one server must have `deployment_instance: true`, all other need this variable to be unset. The hosts of the scale-out cluster need to be listed in hana_addhosts

TIP: If you want to install multiple HANA instances on one server you can add more than one instance here and the installer will loop over these instances.

Now create your playbook and run the installation. Log into `hana1.example.com` and assume user `hxeadm` to see if Hana is running:
-----
[root@hana1-GUID ~]# su - hxeadm
Last login: Fri May 11 18:26:48 EDT 2018
hxeadm@hana1-GUID:/usr/sap/HXE/HDB90> HDB info
USER       PID  PPID %CPU    VSZ   RSS COMMAND
hxeadm   11618 11617  1.6 116308  2940 -bash
hxeadm   11680 11618  2.0 113260  1640  \_ /bin/sh /usr/sap/HXE/HDB90/HDB info
hxeadm   11711 11680  0.0 151040  1804      \_ ps fx -U hxeadm -o user,pid,ppid,pcpu,vsz,rss,args
hxeadm    6805     1  0.0  43232  1888 sapstart pf=/hana/shared/HXE/profile/HXE_HDB90_hana1-GUID
hxeadm    6814  6805  0.1 225944 31780  \_ /usr/sap/HXE/HDB90/hana1-GUID/trace/hdb.sapHXE_HDB90 -d -nw -f /usr/sap/HXE/HDB90/hana1-GUID/daemon.ini pf=/usr/sap/HXE/SYS/profile/HXE_HDB90_hana1-GUID
hxeadm    6830  6814 53.7 7641816 5200160      \_ hdbnameserver
hxeadm    7149  6814  1.3 1254272 259132      \_ hdbcompileserver
hxeadm    7151  6814 57.3 3253036 2306784      \_ hdbpreprocessor
hxeadm    7194  6814 51.7 7298972 5381920      \_ hdbindexserver -port 39003
hxeadm    7196  6814  3.3 2038712 936348      \_ hdbxsengine -port 39007
hxeadm    8293  6814  1.8 1567760 292932      \_ hdbwebdispatcher
hxeadm    6726     1  0.4 519388 23088 /usr/sap/HXE/HDB90/exe/sapstartsrv pf=/hana/shared/HXE/profile/HXE_HDB90_hana1-GUID -D -u hxeadm

-----

WARNING: *Solution Below*

You need to create the following files:

* The required playbook: `./install-hana.yml`:
-----
---
- name: Install SAP HANA
  hosts: hana1.example.com
  become: yes

  vars:
              #####################################################
              # Default Subscription Information for HANA Servers
              # used in: mk-ansible-roles.rhn-subscribe

              satellite_server: satellite.example.com
              reg_activation_key: sap-hana
              reg_organization_id: RHPDS_Demo
              reg_server_insecure: yes

              reg_osrelease: 7.4
              repo_reset: true
              repositories:
                 - rhel-7-server-e4s-rpms
                 - rhel-sap-hana-for-rhel-7-server-e4s-rpms

              ####################################################
              # Default Timeserver settings
              # used in: rhel-system-roles.timeserver

              ntp_servers:
                      - hostname: 0.rhel.pool.ntp.org
                        iburst: yes
                      - hostname: 1.rhel.pool.ntp.org
                        iburst: yes
                      - hostname: 2.rhel.pool.ntp.org
                        iburst: yes
                      - hostname: 3.rhel.pool.ntp.org
                        iburst: yes

              # SAP Precoonfigure role
              # SAP-Media Check
              install_nfs: "tower.example.com:/export"
              installroot: /install/hxe
              installversion: "HANA_EXPRESS_20"
              hana_installdir: "{{ installroot + '/' + installversion }}"

              hana_pw_hostagent_ssl: "MyS3cret!"
              id_user_sapadm: "30200"
              id_group_shm: "30220"
              id_group_sapsys: "30200"
              pw_user_sapadm_clear: "MyS3cret!"

  roles:
              - { role: mk-ansible-roles.subscribe-rhn }
              - { role: mk-ansible-roles.saphana-preconfigure }
              - { role: mk-ansible-roles.saphana-deploy }
-----

* The required host_vars file: `./host_vars/hana1.example.com`:
-----

---
### Disk Configuration
disks:
        /dev/vdb: vg00
logvols:
        hana_shared:
                size: 32G
                vol: vg00
                mountpoint: /hana/shared
        hana_data:
                size: 32G
                vol: vg00
                mountpoint: /hana/data
        hana_logs:
                size: 16G
                vol: vg00
                mountpoint: /hana/logs
        usr_sap:
                size: 50G
                vol: vg00
                mountpoint: /usr/sap

hostname: "{{ ansible_hostname }}"
deployment_instance: true

instances:
  inst01:
    id_user_sidadm: "30210"
    pw_user_sidadm: "Adm12356"
    hana_pw_system_user_clear: "System123"
    hana_components: "client,server"
    hana_system_type: "Master"
    id_group_shm: "30220"
    hana_instance_hostname: "{{ ansible_hostname }}"
    hana_addhosts:
    hana_sid: HXE
    hana_instance_number: 90
    hana_system_usage: custom
    hdblcm_params: "--ignore=check_platform"
...
-----

Now kick off the installation as user ansible on workstion-GUID:

-----
[ansible@tower-GUID ~]$ ansible-playbook install-hana.yml
-----

TIP: run with -vvv to increase debuglevel to get mor information whats happening

You finished your Lab deploying SAP HANA fully automated. You now know the basics and should be able to integrate this with Satellite, Ansible Tower and even CloudForms. To learn about thes tools join us in one of the upcoming management classes.
It might be useful to split playbooks and keep variables separately. An example of this is used in tower and can be found in the directory: `~awx/projects/rhdemos`

In this directory the variables are kept in `group_vars/hana` and in `host_vars/hana1.example.com`

=== Bonus Labs

==== Install and configure Insights

WARNING: UNTESTED with Satellite Server

Follow the instructions of https://access.redhat.com/products/red-hat-insights#getstarted[ the getting started guide^]

WARNING: *Solution Below*

As we are in an ansible training we use an ansible playbook to add insights.

1. Install the insights role from galaxy:

    # ansible-galaxy install redhataccess.redhat-access-insights-client

2. Create a playbook `install-insights.yml` to install to configure Insights

   # Playbook installing Insights
   ---
   - hosts: hana1.example.com
     become: yes
     roles:
     - { role: redhataccess.redhat-access-insights-client, when: ansible_os_family == 'RedHat' }

3. Run the playbook

   # ansible-playbook install-insights.yml

4. Goto https://access.redhat.com/insights[the portal^] to see the results

==== Upgrade HANA Server
Do you know how to upgrade SAP HANA servers

1. with new RHEL patches?
2. to a new RHEL minor reg_osrelease?

WARNING: *Solution Below*

1. Update the system to the latest patches in the current RHEL minor release:
* Make sure you have your release set to the current minor release:

  [root@hana1-GUID ~]# subscription-manager release
  Release: 7.4

* update the system

  [root@hana1-GUID ~]# yum -y update
* stop the HANA database

  [root@hana1-GUID ~]# su - hxeadm
  hxeadm@hana1-GUID.rhpds:/usr/sap/HXE/HDB90> HDB stop


* reboot
  [root@hana1-GUID ~]# reboot

* login and start HANA again (in case it is not started automatically)

  [root@tower-GUID ~]# ssh hana1.example.com
  [root@hana1-GUID ~]# su - hxeadm
  hxeadm@hana1-GUID.rhpds:/usr/sap/HXE/HDB90> HDB start

////
THIS MODULE WILL BE POSIBLE WHEN 7.6 validated

2. Update the system to the latest patches in a newer RHEL minor release:

* Check available releases:

  [root@hana1-GUID ~]# subscription-manager release --list
  +-------------------------------------------+
            Available Releases
  +-------------------------------------------+
  7.0
  7.1
  7.2
  7.3
  7.4
  7.5
  7.6
  7Server

* Set the desired release 7.6

  [root@hana1-GUID ~]# subscription-manager release --set 7.6
  Release set to: 7.6

* update the systems and reboot as described in the previous steps
////

Do you really want to do this manually? If not, here is a playbook that covers both upgrade scenarios. If you change `reg_osrelease`, an upgrade to another RHEL release will be performed.

-----
- name: Update Hana Server
  hosts: hana1.example.com
  become: yes

  vars:
              # Repositories setup
              reg_osrelease: 7.4
              repo_reset: false
              repositories:
                 - rhel-7-server-e4s-rpms
                 - rhel-sap-hana-for-rhel-7-server-e4s-rpms

              sid: hxe

  roles:
              ## We can use this role to change  repsoitories, if we need to and to switch the minor relase from eus to e4s or similar.
              - { role: mk-ansible-roles.subscribe-rhn }

  tasks:
              ## update the system
              - name: ensure the the system is updated
                yum: name=* state=latest

              ## stop database
              - name: ensure HANA is stopped
                command: su - "{{ sid + 'adm' }}" -c "HDB stop"

              # Reboot the server now and wait until it is back
              # inspired by https://support.ansible.com/hc/en-us/articles/201958037-Reboot-a-server-and-wait-for-it-to-come-back
              - name: restart machine
                shell: sleep 2 && shutdown -r now "Ansible updates triggered"
                async: 1
                become: true
                ignore_errors: true

              - name: waiting for server to come back
                local_action: wait_for host={{ inventory_hostname }} port=22 state=started delay=90 sleep=2 timeout=900
                become: false

              ## start database again
              - name: ensure HANA is started
                command: su - "{{ sid + 'adm' }}" -c "HDB start"


-----

You could also think about splitting this playbook into separate roles, that can be reused in differetn playbooks, such as:

* Stop HANA instances
* Start HANA instances
* Update Server. In this role you could implement reboot as a handler, so that a system is only rebooted if a new kernel or other patch which requires a reboot is installed

== Deploying HANA with Tower
You have deployed `hana1.example.com` from the commandline, now look how easy this is with tower.

We use the prepared playbooks in `~awx/projects/rhdemo`

Login to tower with know credentials
get familiar with

 * project RH demo
 * the inventory RH demo
 * the job Templates

Run the workflow template enter HANA SID and HANA instance number and you are done.

NOTE: The inventory name in Tower does not match hana. To get the group variables used, you need to rename the file or the inventory appropriately or you copy the content of the file `group_vars/hana` in the variable definition in tower. As a good practise you can copy only the variables to tower that can be different between installations and keep the variables that are global to your site in the files in the SCM system as default values.

== The End

Congratulations, you finished your labs! We hope you enjoyed your first steps using Ansible as much as we enjoyed creating the labs.
